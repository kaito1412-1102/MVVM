Trong MVP, Presenter đóng vai trò là nơi xử lý logic và điều khiển View. Nói cách khác, mọi business của app sẽ được tách ra và xử lý riêng biệt ở layer này. Presenter sau khi nhận event từ View layer sẽ request Model layer và nhận notification từ nó và tiến hành update ngược trở lại lên View layer. Chúng ta đến với sơ đồ bên dưới. 
Trong MVP, Presenter và View có quan hệ 1-1, tức là một Presenter chỉ tương tác với một View và ngược lại. Vì mọi logic đều xử lý trong Presenter dẫn đến nó có thể bị overload - một cách gọi khi quá nhiều thứ tập trung ở đây - và tất nhiên, bạn rất khó để kiểm soát nó, code sẽ trở nên rối và khó tiếp cận hơn. Để giải quyết vấn đề đó, chúng ta có thể tách việc xử lý logic nhỏ thành nhiều feature khác nhau bằng cách tạo một Service layer trung gian đóng vai trò connect giữa Presenter và Model, hoặc sẽ gộp các logic về data process tập trung theo Feature hoặc Model trước khi expose cho Presenter, và tôi nhận thấy Repository Pattern rất hiệu quả trong việc này.

MVVM
MVVM thực chất được xây dựng dựa trên MVP và cấu trúc cơ bản là tương đồng, tuy nhiên có vài điểm khác biệt. Nếu như MVP tập trung vào behavior của Presenter để interact với View thì MVVM lại khác, nó dựa vào notification từ ViewModel khi có thay đổi về data và update View, tất nhiên View sẽ đăng ký nhận notification từ ViewModel. Nói cách khác, ViewModel không có bất kỳ behavior nào để tương tác với View mà chính View sẽ lắng nghe sự thay đổi từ ViewModel. Bên cạnh đó, nếu như Presenter connect với View theo quan hệ 1-1 thì ViewModel với View lại là 1-n, tức là một ViewModel có thể connect với nhiều View

![Screenshot (161)](https://user-images.githubusercontent.com/68551096/122365775-29928400-cf85-11eb-9eac-bdc0d5ce071c.png)
